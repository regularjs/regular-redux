{"./":{"url":"./","title":"安装","keywords":"","body":"安装 NPM npm install rgl-redux --save 运行要求 regularjs 0.6.0-beta.1以上版本 webpack+babel 用于构建基于ES6语法的应用 "},"src/start.html":{"url":"src/start.html","title":"开始","keywords":"","body":"rgl-redux内置一个类Store，是对Redux的store的集成封装，提供简单配置reducer、state、middleware...的方法，还实现了undo、redo的功能。 创建一个最简单的store import {Store} from 'rgl-redux'; const store = new Store({ state: { count: 0 }, reducers: { count(state, payload) { let count = state.count; count++; return Object.assign({}, state, {count}); } } }); 现在，你可以通过 store.state 来获取状态对象，以及通过 store.dispatch 方法触发状态变更： console.log(store.state) // {\"count\": 0} store.dispatch(\"count\"); console.log(store.state) // {\"count\": 1} 这样就可以简单地定义一个state数据，同时可以通过reducer改变state的数据，后面我们讲如何将store注入到Regular组件当中以供使用 "},"src/storeProvider.html":{"url":"src/storeProvider.html","title":"StoreProvider组件","keywords":"","body":"StoreProvider组件 假设App组件是你们项目的一个组件，把StoreProvider作为App组件的$outer(父组件)，并通过connect函数包装App组件来注入store。 import 'rgl-redux'; import './module/App'; //一个regular组件 import store from './module/store' //创建的store实例 const AppContainer = Regular.extend({ template: ` `, config(data) { data.store = store; }, }); 记得import进rgl-redux来定义StoreProvider组件，并且传入store "},"src/connect.html":{"url":"src/connect.html","title":"connect","keywords":"","body":"connect函数 import { connect } from 'rgl-redux'; const App = Regular.extend({ name: 'App', template: '{count}' }); export default connect({ mapState(state) { return { count: state.count, }; }, dispatch: true, })(App); connect接收一个配置对象config，App是StoreProvider组件的一个子组件(在模板中实例化的，不能是new出来inject进去的)。经过以上代码，你就可以在App的方法中这样调用： this.$dispatch(\"count\"); 然后，mapState会自动执行，返回一个对象，返回的对象属性会自动注入到组件的data中，从而更新视图。 "},"src/state.html":{"url":"src/state.html","title":"State","keywords":"","body":"State 单一state树 在new Store的config中传入state属性就可以定义一个state import {Store} from 'rgl-redux'; const store = new Store({ ... state: { count: 0, languages: [ {id: 1, name: 'regular'}, {id: 2, name: 'regular'}, {id: 3, name: 'regular'}, ] } ... }); console.log(store.state.count) //0 模块化state 什么叫做模块化的state，在项目开发中，如果你的业务代码逻辑较为复杂，那么你的state也会跟着变得复杂，这时候切分模块就提高了可维护性。 state: { count: 0, languages: [ {id: 1, name: 'regular'}, {id: 2, name: 'regular'}, {id: 3, name: 'regular'} ] } 以上的state你可以把languages当作是全局state的一个模块，这个模块名就是languages，那么你可以在config里这样定义： const store = new Store({ ... state: { count: 0 }, modules: { languages: { state: [ {id: 1, name: 'regular'}, {id: 2, name: 'regular'}, {id: 3, name: 'regular'} ] } } ... }); 在config.modules中定义一个languages模块，它的state是一个数组，rgl-redux会自动帮我们将state合并成： state: { count: 0, languages: [ {id: 1, name: 'regular'}, {id: 2, name: 'regular'}, {id: 3, name: 'regular'} ] } 模块state的嵌套 const store = new Store({ ... state: { count: 0 }, modules: { languages: { state: { name: 'regular' }, modules: { other: { state: { name: 'redux' } } } } } ... }); 这样合并后： { count: 0, languages: { name: 'regular', other: { name: 'redux' } } } 因此，你可以把new Store传入的config当作是最顶层的一个模块。 state合并策略combineMode 合并策略分为3种： 'assign'，默认值 'extend' 'replace'在模块的属性直接定义即可： const store = new Store({ state: { count: 0, languages: { one: 'one', two: 'two' } }, modules: { languages: { combineMode: 'extend', state: { one: 'sub-one', three: 'sub-three' } } } }); 下面看个例子来区别3种模式： const store = new Store({ state: { count: 0, languages: { one: 'one', two: 'two' } }, modules: { languages: { state: { one: 'sub-one', three: 'sub-three' } } } ... }); assign的话合并的话，子模块state会覆盖全局state对应部分的相同属性： { count: 0, languages: { one: 'sub-one', two: 'two', three: 'sub-three' } } extend的话合并的话，子模块state会覆盖全局state对应部分的不存在的属性： { count: 0, languages: { one: 'sub-one', three: 'sub-three' } } replace的话合并的话，子模块state会全部覆盖全局state对应部分： { count: 0, languages: { one: 'one', two: 'two', three: 'sub-three' } } 必须注意的一点 如果一个模块有子模块，那么它的state就必须为一个对象，例如以下定义就会引发错误： const store = new Store({ state: [1, 2, 3], modules: { languages: { state: { one: 'sub-one' } } } }); 这样合并的时候就会有麻烦，所以在定义后rgl-redux会对其进行检测，并给出错误提示 "},"src/reducer.html":{"url":"src/reducer.html","title":"Reuder","keywords":"","body":"Reducer 提交修改 更改redux的store中的状态的唯一方法是提交一个修改： store.dispatch(\"count\", { step: 2 }) dispatch函数接受一个type和payload作为参数，这是会触发一个回调函数来处理state的变化。如果你在store这样定义了reducer： new Store({ state: { count: 0 }, reducers: { count(state, payload) { let count = state.count; let step = payload.step || 1; count = count + step; return Object.assign({}, state, {count}) } } }) 调用dispatch的时候，reducer函数就会执行，这个函数return的state会替换state，从而修改数据。 模块化reducer 和state一样，reducer也有模块化，这个模块化是什么意思呢？其实很简单，只是改变注入reducer的state，将模块的state注入到reducer中，例如： const store = new Store({ state: { count: 0, module: { count: 2 } }, reducers: { count(state, payload) { console.log(state); // {count: 2} let count = state.count; let step = payload.step || 1; count = count + step; return Object.assign({}, state, {count}) } } }) store.dispatch('count'); 注入到reducer的state是一个局部state，并且你返回的state就是module的state 提交载荷payload 你可以向store.dispatch传入额外的参数： store.dispatch('count', { step: 1 }) 第二个参数就是payload 内置reducer rgl-redux提供了几个内置的reducer用来执行一些特定的操作 undo撤销 store.dispatch('undo') redo重做 store.dispatch('redo') @init/state初始化/重置state store.dispatch('@init/state') 由于目前rgl-redux有个问题：组件创建后mapState并不会执行，所以可以通过这个dispatch进行初始化，触发mapState。 @replace/state替换state store.dispatch('@replace/state', { state: newState }) payload的一些特殊参数 payload.replace = true //表示本次dispach产生的state会替换上一次的提交 payload.clean = true //表示只保存本次提交 payload.record = false //表示这次产生的state不会进历史 payload.steps = 2 // 表示undo, redo的步长，只在undo, redo的时候有效 "},"src/immuable.html":{"url":"src/immuable.html","title":"不可变数据","keywords":"","body":"不可变数据 我们一步一步讲讲什么叫做不可变数据，而不可变数据是实现undo、redo的关键 共享与可变 我们都知道Javascript的对象、数组、函数是引用类型，变量名只是保存了它们的引用，真正的数据存放在堆内存中，所以可能多个变量共享同一份数据，例如： let a = [1, 2, 3]; let b = a; console.log(a); //1, 2, 3 console.log(b); //1, 2, 3 如果你修改了其中某个数组的数据： let a = [1, 2, 3]; let b = a; a[0] = 0; console.log(a); //0, 2, 3 console.log(b); //0, 2, 3 这时两个数组都变化了。 undo、redo的思路 作为一个复杂的页面应用，我们可能会接到产品的需求：做个撤销、重做的功能吧。对于redux应用，我们可能有两个思路： 针对每一个reducer写一个撤销的reducer，需要撤销的时候只需要找到对应的reducer，然后dispatch即可。 使用一个数组存放所有的state，撤销重做的时候移动数组的指向就可以了。 对于复杂的应用来说，第一种方法会带来许多的工作量，并且使得代码逻辑变得复杂，所以选择第二个。 可变数据带来的麻烦 let state = { members: [1, 2, 3] } let timeline = [state]; let index = 0; //新增一个操作的时候，如修改menbers第一个元素为0 let newState = state; newState.members[0] = 0; timeline[++index] = newState; 我们的思路很简单，就是获取到newState，然后修改members第0个值，最后添加到timline，把index加1，然而： console.log(timeline); // [{members: [0, 2, 3]}, {members: [0, 2, 3]}] 可以看到，原来的state也跟着改变了，无奈。 使用deepClone 相信你也想到了，上面的代码使用深拷贝不就解决了，答案是，没错。 let state = { members: [1, 2, 3] } let timeline = [state]; let index = 0; //新增一个操作的时候，如修改menbers第一个元素为0 let newState = JSON.parse(JSON.stringify(state)); //这是代表简单的deepClone newState.members[0] = 0; timeline[++index] = newState; console.log(timeline); // [{members: [1, 2, 3]}, {members: [0, 2, 3]}] 看起来目的达成了，但是有2个问题，每一步操作都必须生成一个完全不同的对象，开销打，而且无法解决当state上有函数，有循环引用的问题。 使用不可变数据 其实不可变数据很好理解，直接上代码： let state = { members: [1, 2, 3] } let timeline = [state]; let index = 0; //新增一个操作的时候，如修改menbers第一个元素为0 let newState = Object.assign({}, state); newState.members = newState.members.slice() newState.members[0] = 0; timeline[++index] = newState; console.log(timeline); // [{members: [1, 2, 3]}, {members: [0, 2, 3]}] 为了解决共享数据的问题，我们将state从顶层到members，将引用都修改了，于是共享就实效了，这个就是不可变数据，对象可用Object.assign，数组用slice就可以解决。但是每次都自己写有点麻烦，所以封装成函数 set(target, path, newValue[, config]) set可以接受4个参数：设置对象，路径，新值，额外配置 target设置对象：可以是对象或者数组 path路径：需要替换的值的路径，例如下方代码'member.0'代表state.member[0] newValue: 新值，不解释 config：配置 autoCreated，默认为false，为true的时候，路径错误，则会自动创建key assign，新值与旧值的合并策略，默认false import {set} from 'rgl-redux'; let state = { members: [1, 2, 3] } let timeline = [state]; let index = 0; //新增一个操作的时候，如修改menbers第一个元素为0 let newState = set(state, 'members.0', 0); console.log(timeline); // [{members: [1, 2, 3]}, {members: [0, 2, 3]}] 返回一个不可变数据。 get(target, path) set可以接受2个参数：设置对象，路径 target设置对象：可以是对象或者数组 path路径：路径，例如下方代码'member.0'代表state.member[0]; 只是单纯获取到值，避免了undefined.key的错误 import {get} from 'rgl-redux'; let state = { members: [1, 2, 3] } console.log(get(state, 'member.0')) // 1 console.log(get(state, 'unknow.a.c.b')) // undefined splice(target, path, ...args) splice可以接受多个参数 target设置对象：可以是对象或者数组 path路径：路径，例如下方代码'member.0'代表state.member[0]; 后面的参数和数组的splice是一样的 只是单纯获取到值，如果path获取到的不是一个数组，这时候相当于get import {splice} from 'rgl-redux'; let state = { members: [1, 2, 3] } console.log(get(state, 'member', 0, 1)) // {members: [2, 3]} "},"src/middleware.html":{"url":"src/middleware.html","title":"Middleware","keywords":"","body":"中间件 rgl-redux中间件就是一个函数，它接收两个参数context和next. context context是一个对象，有两个方法：dispatch和getState，即为store.dispatch和store.getState() next是一个函数，只有执行这个方法，本次dispatch的reducer才会执行 function myMiddleware(context, next) { console.log(\"I'm before next\", context.getState()); next() console.log(\"I'm after next\", context.getState()); } const store = new Store({ state: { count: 0 }, reducers: { count(state, payload) { console.log(\"I'm in reducer\"); let count = state.count; let step = payload.step || 1; count = count + step; return Object.assign({}, state, {count}) } }, middlewares: [myMiddleware] }) store.dispatch('count'); // I'm before next {count: 0} // I'm in reducer // I'm after next {count: 1} "},"src/modifier.html":{"url":"src/modifier.html","title":"Modifier","keywords":"","body":"modifier modifier也是一个函数，返回一个reducer，是reducer的高阶函数，用于对state进行其他修改，例如rgl-redux的undo、redo就是利用modifier实现的功能。和middleware不同的是，middleware常用于做与state的无关的事，例如涌来做日志记录，数据更新到数据库等等，而modifier是对reducer返回的state经过再次加工。 function myModifiers(reducer) { return (state, action) { //do something let newState = reducer(state, action); //do something return newState; //这里要return新的state } } new Store({ state: { count: 0 }, reducers: { }, modifiers:[myModifiers] }); "},"src/config.html":{"url":"src/config.html","title":"config","keywords":"","body":"new Store(config) config.undoable 是否可以undo、redo，默认为true。 config.state 见state config.reducers 见reducers config.middlewares 见middleware config.modifiers 见modifier config.modules 分散state、reducer的文档了 "}}